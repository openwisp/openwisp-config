#!/bin/sh

# parse options
while [ -n "$1" ]; do
	case "$1" in
		--url) export URL=${2%/}; shift;;  # strip trailing slash
		--interval) export INTERVAL=$2; shift;;
		--verify-ssl) export VERIFY_SSL=$2; shift;;
		--uuid) export UUID="$2"; shift;;
		--key) export KEY="$2"; shift;;
		--shared-secret) export SHARED_SECRET="$2"; shift;;
		--merge-default) export MERGE_DEFAULT="$2"; shift;;
		--test-config) export TEST_CONFIG="$2"; shift;;
		--test-script) export TEST_SCRIPT="$2"; shift;;
		-*)
			echo "Invalid option: $1"
			exit 1
		;;
		*) break;;
	esac
	shift;
done

if [ -z "$URL" ]; then
	logger -s "missing required --url option" \
		   -t openwisp \
		   -p daemon.err
	exit 2
fi

if ([ -z "$UUID" ] || [ -z "$KEY" ]) && [ -z "$SHARED_SECRET" ]; then
	logger -s "you must either specify --uuid and --key, or --shared-secret" \
		   -t openwisp \
		   -p daemon.err
	exit 3
fi

INTERVAL=${INTERVAL:-120}
VERIFY_SSL=${VERIFY_SSL:-1}
TEST_CONFIG=${TEST_CONFIG:-1}
WORKING_DIR="/tmp/openwisp"
BASEURL="$URL/controller"
CONFIGURATION_ARCHIVE="$WORKING_DIR/configuration.tar.gz"
CONFIGURATION_CHECKSUM="$WORKING_DIR/checksum"
CONFIGURATION_BACKUP="$WORKING_DIR/backup.tar.gz"
REGISTRATION_PARAMETERS="$WORKING_DIR/registration_parameters"
TEST_CHECKSUM="$WORKING_DIR/test_checksum"
STATUS_REPORT="$WORKING_DIR/status_report"
APPLYING_CONF="$WORKING_DIR/applying_conf"
REGISTRATION_URL="$URL/controller/register/"
DEFAULT_DIR="/etc/openwisp-config-defaults"
FETCH_COMMAND="curl -s"
mkdir -p $WORKING_DIR
mkdir -p $DEFAULT_DIR

if [ "$VERIFY_SSL" != "1" ]; then
	FETCH_COMMAND="$FETCH_COMMAND -k"
fi

if [ -n "$MERGE_DEFAULT" ]; then
	# replace commas with spaces
	MERGE_DEFAULT=$(echo $MERGE_DEFAULT | tr ',' ' ')
fi

# ensures we are dealing with the right web server
check_header(){
	local is_controller=$(grep -c "X-Openwisp-Controller: true" $1)
	if [ $is_controller -lt 1 ]; then
		logger -s "Invalid url: missing X-Openwisp-Controller header" \
			   -t openwisp \
			   -p daemon.err
		exit 4
	fi
}

# performs automatic registration
register() {
	logger -s "Registering new device" \
		   -t openwisp \
		   -p daemon.info
	# gets the mac address of the first interface that shows in ifconfig
	local name=$(ifconfig | grep -v lo | grep HWaddr | awk '/HWaddr/ { print $5 }' | head -n 1)
	local backend="netjsonconfig.OpenWrt"
	local params="secret=$SHARED_SECRET&name=$name&backend=$backend"
	$($FETCH_COMMAND -i --data $params $REGISTRATION_URL > $REGISTRATION_PARAMETERS)
	local exit_code=$?

	# report eventual failures and return
	if [ "$exit_code" != "0" ]; then
		logger -s "Failed to connect to controller (register): curl exit code $exit_code" \
		       -t openwisp \
		       -p daemon.err
		return 1
	fi

	# exit if not openwisp
	check_header $REGISTRATION_PARAMETERS

	# exit if controller returns errors
	if [ $(head -n 1 $REGISTRATION_PARAMETERS | grep -c "201 Created") -lt 1 ]; then
		local message=$(cat $REGISTRATION_PARAMETERS | grep "error:")
		logger -s "Registration failed! $message" \
			   -t openwisp \
			   -p daemon.err
		exit 5
	fi

	# set configuration options and reload
	export UUID=$(cat $REGISTRATION_PARAMETERS | grep uuid | awk '/uuid: / { print $2 }')
	export KEY=$(cat $REGISTRATION_PARAMETERS | grep key | awk '/key: / { print $2 }')
	uci set openwisp.http.uuid=$UUID
	uci set openwisp.http.key=$KEY

	# remove shared secret to avoid accidental re-registration
	uci set openwisp.http.shared_secret=""
	uci commit openwisp
	rm $REGISTRATION_PARAMETERS
	logger -s "Device registered successfully as $name, id: $UUID" \
		   -t openwisp \
		   -p daemon.info
}

# gets checksum from controller
get_checksum() {
	$($FETCH_COMMAND -i $CHECKSUM_URL > $1)
	local exit_code=$?

	if [ "$exit_code" != "0" ]; then
		logger -s "Failed to connect to controller (checksum): curl exit code $exit_code" \
		       -t openwisp \
		       -p daemon.err
		return 2
	fi

	if [ $(head -n 1 $1 | grep -c "200 OK") -lt 1 ]; then
		local status=$(head -n 1 $1)
		logger -s "Failed to retrieve checksum: $status" \
			   -t openwisp \
			   -p daemon.err
		return 3
	fi
	check_header $1
}

# returns 1 if configuration in controller has changed
configuration_changed() {
	local CURRENT_CHECKSUM=$(tail -n 1 $CONFIGURATION_CHECKSUM 2> /dev/null)
	get_checksum $CONFIGURATION_CHECKSUM
	local exit_code=$?

	if [ "$exit_code" != "0" ]; then
		return $exit_code
	fi

	local REMOTE_CHECKSUM=$(tail -n 1 $CONFIGURATION_CHECKSUM 2> /dev/null)

	if [ "$CURRENT_CHECKSUM" != "$REMOTE_CHECKSUM" ]; then
		logger -s "Configuration in controller has changed" \
		       -t openwisp \
		       -p daemon.info
		return 1
	fi

	return 0
}

# applies a specified configuration archive
apply_configuration() {
	local sleep_time=${2-2}
	# store default config (if enabled)
	store_default
	# -r restores the specified configuration archive
	sysupgrade -r $1
	local exit_code=$?

	if [ "$exit_code" != "0" ]; then
		logger -s "Could not restore configuration: sysupgrade exit code $exit_code" \
		       -t openwisp \
		       -p daemon.crit
		return 1
	fi
	# merge default config (if enabled)
	merge_default
	# apply changes and wait 2 seconds
	/usr/sbin/apply_config
	sleep $sleep_time
}

# report configuration status: "running" or "error"
report_status() {
	# retry several times
	for i in $(seq 1 10); do
		$($FETCH_COMMAND -i --data "key=$KEY&status=$1" $REPORT_URL > $STATUS_REPORT)
		local exit_code=$?
		if [ "$exit_code" == "0" ]; then
			break
		else
			sleep 2
		fi
	done

	if [ "$exit_code" != "0" ]; then
		logger -s "Failed to connect to controller (report-status): curl exit code $exit_code" \
		       -t openwisp \
		       -p daemon.err
		return 2
	fi

	if [ $(head -n 1 $STATUS_REPORT | grep -c "200 OK") -lt 1 ]; then
		local status=$(head -n 1 $STATUS_REPORT)
		logger -s "Failed to report status: $status" \
		       -t openwisp \
		       -p daemon.err
		return 3
	fi
	check_header $STATUS_REPORT
	rm $STATUS_REPORT
}

# performs configuration test and reports result
test_configuration() {
	sysupgrade -b $CONFIGURATION_BACKUP

	logger -s "Testing configuration" \
	       -t openwisp \
	       -p daemon.info
	apply_configuration $1 6  # wait 6 seconds instead of 2

	if [ -z "$TEST_SCRIPT" ]; then
		get_checksum $TEST_CHECKSUM
		local test_ret=$?
		rm $TEST_CHECKSUM
	else
		$TEST_SCRIPT
		local test_ret=$?
	fi

	if [ $test_ret -gt 0 ]; then
		logger -s "Configuration test failed! Restoring previous backup" \
		       -t openwisp \
		       -p daemon.err
		apply_configuration $CONFIGURATION_BACKUP
		report_status "error"
		local ret=1
	else
		report_status "running"
		local ret=0
	fi

	rm $CONFIGURATION_BACKUP
	return $ret
}

# stores default configuration files that will be merged with the
# configuration downloaded from the controller
store_default() {
	if [ -z "$MERGE_DEFAULT" ]; then
		return 0
	fi

	for config in $MERGE_DEFAULT; do
		# store default config only if not already done previously
		if [ ! -f "$DEFAULT_DIR/$config" ] && [ -f "/etc/config/$config" ]; then
			# system is a special case:
			# we need to remove hostname and timezone because these
			# are automatically generated by the controller
			if [ "$config" == "system" ]; then
				uci delete system.@system[0]
				uci commit system
			fi
			cp "/etc/config/$config" "$DEFAULT_DIR/$config"
			logger -s "Stored $DEFAULT_DIR/$config" \
				   -t openwisp \
				   -p daemon.info
		fi
	done
}

# merges default configuration files stored by store_default()
merge_default() {
	if [ -z "$MERGE_DEFAULT" ]; then
		return 0
	fi

	for config in $MERGE_DEFAULT; do
		if [ -f "$DEFAULT_DIR/$config" ]; then
			uci import -m -f $DEFAULT_DIR/$config $config
			uci commit $config
		fi
	done
}

# downloads configuration from controller
# performs test (if testing enabled)
# and applies it
update_configuration() {
	# download configuration
	$($FETCH_COMMAND $CONFIGURATION_URL -o $CONFIGURATION_ARCHIVE)
	local exit_code=$?

	if [ "$exit_code" != "0" ]; then
		logger -s "Failed to connect to controller (download-config): curl exit code $exit_code" \
		       -t openwisp \
		       -p daemon.err
		return 3
	fi

	# control file to avoid reloading the agent while
	# configuration is still being applied
	touch $APPLYING_CONF

	if [ "$TEST_CONFIG" == "1" ]; then
		test_configuration $CONFIGURATION_ARCHIVE
	else
		apply_configuration $CONFIGURATION_ARCHIVE
	fi

	rm $APPLYING_CONF

	if [ "$?" == "0" ]; then
		logger -s "Configuration applied" \
		       -t openwisp \
		       -p daemon.info
	fi
}

# ensure both UUID and KEY are defined
# otherwise perform registration
if [ -z "$UUID" ] || [ -z "$KEY" ]; then
	# do not crash if controller can't be reached
	# but retry every ($INTERVAL / 4) seconds
	# (device might be unplugged, unconfigured or connecting)
	until register
	do
		sleep $(expr $INTERVAL / 4)
	done
fi

# these variables are evaluated here because "register()" might set UUID and KEY
CONFIGURATION_URL="$BASEURL/download-config/$UUID/?key=$KEY"
CHECKSUM_URL="$BASEURL/checksum/$UUID/?key=$KEY"
REPORT_URL="$BASEURL/report-status/$UUID/"

while true
do
	configuration_changed

	if [ "$?" == "1" ]; then
		update_configuration
	fi

	sleep $INTERVAL
done
